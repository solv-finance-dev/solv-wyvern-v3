{
  "language": "Solidity",
  "sources": {
    "contracts/exchange/Exchange.sol": {
      "content": "/*\n\n  << Exchange >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"./ExchangeCore.sol\";\n\n/**\n * @title Exchange\n * @author Wyvern Protocol Developers\n */\ncontract Exchange is ExchangeCore {\n\n    /* external ABI-encodable method wrappers. */\n\n    function hashOrder_(address registry, address maker, address staticTarget, bytes4 staticSelector, bytes calldata staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt)\n        external\n        pure\n        returns (bytes32 hash)\n    {\n        return hashOrder(Order(registry, maker, staticTarget, staticSelector, staticExtradata, maximumFill, listingTime, expirationTime, salt));\n    }\n\n    function hashToSign_(bytes32 orderHash)\n        external\n        view\n        returns (bytes32 hash)\n    {\n        return hashToSign(orderHash);\n    }\n\n    function validateOrderParameters_(address registry, address maker, address staticTarget, bytes4 staticSelector, bytes calldata staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt)\n        external\n        view\n        returns (bool)\n    {\n        Order memory order = Order(registry, maker, staticTarget, staticSelector, staticExtradata, maximumFill, listingTime, expirationTime, salt);\n        return validateOrderParameters(order, hashOrder(order));\n    }\n\n    function validateOrderAuthorization_(bytes32 hash, address maker, bytes calldata signature)\n        external\n        view\n        returns (bool)\n    {\n        return validateOrderAuthorization(hash, maker, signature);\n    }\n\n    function approveOrderHash_(bytes32 hash)\n        external\n    {\n        return approveOrderHash(hash);\n    }\n\n    function approveOrder_(address registry, address maker, address staticTarget, bytes4 staticSelector, bytes calldata staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired)\n        external\n    {\n        return approveOrder(Order(registry, maker, staticTarget, staticSelector, staticExtradata, maximumFill, listingTime, expirationTime, salt), orderbookInclusionDesired);\n    }\n\n    function setOrderFill_(bytes32 hash, uint fill)\n        external\n    {\n        return setOrderFill(hash, fill);\n    }\n\n    function atomicMatch_(uint[16] memory uints, bytes4[2] memory staticSelectors,\n        bytes memory firstExtradata, bytes memory firstCalldata, bytes memory secondExtradata, bytes memory secondCalldata,\n        uint8[2] memory howToCalls, bytes32 metadata, bytes memory signatures)\n        public\n        payable\n    {\n        return atomicMatch(\n            Order(address(uints[0]), address(uints[1]), address(uints[2]), staticSelectors[0], firstExtradata, uints[3], uints[4], uints[5], uints[6]),\n            Call(address(uints[7]), AuthenticatedProxy.HowToCall(howToCalls[0]), firstCalldata),\n            Order(address(uints[8]), address(uints[9]), address(uints[10]), staticSelectors[1], secondExtradata, uints[11], uints[12], uints[13], uints[14]),\n            Call(address(uints[15]), AuthenticatedProxy.HowToCall(howToCalls[1]), secondCalldata),\n            signatures,\n            metadata\n        );\n    }\n\n}\n"
    },
    "contracts/exchange/ExchangeCore.sol": {
      "content": "/*\n\n  << Exchange Core >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n\nimport \"../lib/StaticCaller.sol\";\nimport \"../lib/ReentrancyGuarded.sol\";\nimport \"../lib/EIP712.sol\";\nimport \"../lib/EIP1271.sol\";\nimport \"../registry/ProxyRegistryInterface.sol\";\nimport \"../registry/AuthenticatedProxy.sol\";\n\n/**\n * @title ExchangeCore\n * @author Wyvern Protocol Developers\n */\ncontract ExchangeCore is ReentrancyGuarded, StaticCaller, EIP712 {\n\n    bytes4 constant internal EIP_1271_MAGICVALUE = 0x1626ba7e;\n    bytes internal personalSignPrefix = \"\\x19Ethereum Signed Message:\\n\";\n\n    /* Struct definitions. */\n\n    /* An order, convenience struct. */\n    struct Order {\n        /* Order registry address. */\n        address registry;\n        /* Order maker address. */\n        address maker;\n        /* Order static target. */\n        address staticTarget;\n        /* Order static selector. */\n        bytes4 staticSelector;\n        /* Order static extradata. */\n        bytes staticExtradata;\n        /* Order maximum fill factor. */\n        uint maximumFill;\n        /* Order listing timestamp. */\n        uint listingTime;\n        /* Order expiration timestamp - 0 for no expiry. */\n        uint expirationTime;\n        /* Order salt to prevent duplicate hashes. */\n        uint salt;\n    }\n\n    /* A call, convenience struct. */\n    struct Call {\n        /* Target */\n        address target;\n        /* How to call */\n        AuthenticatedProxy.HowToCall howToCall;\n        /* Calldata */\n        bytes data;\n    }\n\n    /* Constants */\n\n    /* Order typehash for EIP 712 compatibility. */\n    bytes32 constant ORDER_TYPEHASH = keccak256(\n        \"Order(address registry,address maker,address staticTarget,bytes4 staticSelector,bytes staticExtradata,uint256 maximumFill,uint256 listingTime,uint256 expirationTime,uint256 salt)\"\n    );\n\n    /* Variables */\n\n    /* Trusted proxy registry contracts. */\n    mapping(address => bool) public registries;\n\n    /* Order fill status, by maker address then by hash. */\n    mapping(address => mapping(bytes32 => uint)) public fills;\n\n    /* Orders verified by on-chain approval.\n       Alternative to ECDSA signatures so that smart contracts can place orders directly.\n       By maker address, then by hash. */\n    mapping(address => mapping(bytes32 => bool)) public approved;\n\n    /* Events */\n\n    event OrderApproved     (bytes32 indexed hash, address registry, address indexed maker, address staticTarget, bytes4 staticSelector, bytes staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired);\n    event OrderFillChanged  (bytes32 indexed hash, address indexed maker, uint newFill);\n    event OrdersMatched     (bytes32 firstHash, bytes32 secondHash, address indexed firstMaker, address indexed secondMaker, uint newFirstFill, uint newSecondFill, bytes32 indexed metadata);\n\n    /* Functions */\n\n    function hashOrder(Order memory order)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /* Per EIP 712. */\n        return keccak256(abi.encode(\n            ORDER_TYPEHASH,\n            order.registry,\n            order.maker,\n            order.staticTarget,\n            order.staticSelector,\n            keccak256(order.staticExtradata),\n            order.maximumFill,\n            order.listingTime,\n            order.expirationTime,\n            order.salt\n        ));\n    }\n\n    function hashToSign(bytes32 orderHash)\n        internal\n        view\n        returns (bytes32 hash)\n    {\n        /* Calculate the string a user must sign. */\n        return keccak256(abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR,\n            orderHash\n        ));\n    }\n\n    function exists(address what)\n        internal\n        view\n        returns (bool)\n    {\n        uint size;\n        assembly {\n            size := extcodesize(what)\n        }\n        return size > 0;\n    }\n\n    function validateOrderParameters(Order memory order, bytes32 hash)\n        internal\n        view\n        returns (bool)\n    {\n        /* Order must be listed and not be expired. */\n        if (order.listingTime > block.timestamp || (order.expirationTime != 0 && order.expirationTime <= block.timestamp)) {\n            return false;\n        }\n\n        /* Order must not have already been completely filled. */\n        if (fills[order.maker][hash] >= order.maximumFill) {\n            return false;\n        }\n\n        /* Order static target must exist. */\n        if (!exists(order.staticTarget)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function validateOrderAuthorization(bytes32 hash, address maker, bytes memory signature)\n        internal\n        view\n        returns (bool)\n    {\n        /* Memoized authentication. If order has already been partially filled, order must be authenticated. */\n        if (fills[maker][hash] > 0) {\n            return true;\n        }\n\n        /* Order authentication. Order must be either: */\n\n        /* (a): sent by maker */\n        if (maker == msg.sender) {\n            return true;\n        }\n\n        /* (b): previously approved */\n        if (approved[maker][hash]) {\n            return true;\n        }\n\n        /* Calculate hash which must be signed. */\n        bytes32 calculatedHashToSign = hashToSign(hash);\n\n        /* Determine whether signer is a contract or account. */\n        bool isContract = exists(maker);\n\n        /* (c): Contract-only authentication: EIP/ERC 1271. */\n        if (isContract) {\n            if (ERC1271(maker).isValidSignature(calculatedHashToSign, signature) == EIP_1271_MAGICVALUE) {\n                return true;\n            }\n            return false;\n        }\n\n        /* (d): Account-only authentication: ECDSA-signed by maker. */\n        (uint8 v, bytes32 r, bytes32 s) = abi.decode(signature, (uint8, bytes32, bytes32));\n\n        if (signature.length > 65 && signature[signature.length-1] == 0x03) { // EthSign byte\n            /* (d.1): Old way: order hash signed by maker using the prefixed personal_sign */\n            if (ecrecover(keccak256(abi.encodePacked(personalSignPrefix,\"32\",calculatedHashToSign)), v, r, s) == maker) {\n                return true;\n            }\n        }\n        /* (d.2): New way: order hash signed by maker using sign_typed_data */\n        else if (ecrecover(calculatedHashToSign, v, r, s) == maker) {\n            return true;\n        }\n        return false;\n    }\n\n    function encodeStaticCall(Order memory order, Call memory call, Order memory counterorder, Call memory countercall, address matcher, uint value, uint fill)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        /* This array wrapping is necessary to preserve static call target function stack space. */\n        address[7] memory addresses = [order.registry, order.maker, call.target, counterorder.registry, counterorder.maker, countercall.target, matcher];\n        AuthenticatedProxy.HowToCall[2] memory howToCalls = [call.howToCall, countercall.howToCall];\n        uint[6] memory uints = [value, order.maximumFill, order.listingTime, order.expirationTime, counterorder.listingTime, fill];\n        return abi.encodeWithSelector(order.staticSelector, order.staticExtradata, addresses, howToCalls, uints, call.data, countercall.data);\n    }\n\n    function executeStaticCall(Order memory order, Call memory call, Order memory counterorder, Call memory countercall, address matcher, uint value, uint fill)\n        internal\n        view\n        returns (uint)\n    {\n        return staticCallUint(order.staticTarget, encodeStaticCall(order, call, counterorder, countercall, matcher, value, fill));\n    }\n\n    function executeCall(ProxyRegistryInterface registry, address maker, Call memory call)\n        internal\n        returns (bool)\n    {\n        /* Assert valid registry. */\n        require(registries[address(registry)]);\n\n        /* Assert target exists. */\n        require(exists(call.target), \"Call target does not exist\");\n\n        /* Retrieve delegate proxy contract. */\n        OwnableDelegateProxy delegateProxy = registry.proxies(maker);\n\n        /* Assert existence. */\n        require(delegateProxy != OwnableDelegateProxy(0), \"Delegate proxy does not exist for maker\");\n\n        /* Assert implementation. */\n        require(delegateProxy.implementation() == registry.delegateProxyImplementation(), \"Incorrect delegate proxy implementation for maker\");\n\n        /* Typecast. */\n        AuthenticatedProxy proxy = AuthenticatedProxy(address(delegateProxy));\n\n        /* Execute order. */\n        return proxy.proxy(call.target, call.howToCall, call.data);\n    }\n\n    function approveOrderHash(bytes32 hash)\n        internal\n    {\n        /* CHECKS */\n\n        /* Assert order has not already been approved. */\n        require(!approved[msg.sender][hash], \"Order has already been approved\");\n\n        /* EFFECTS */\n\n        /* Mark order as approved. */\n        approved[msg.sender][hash] = true;\n    }\n\n    function approveOrder(Order memory order, bool orderbookInclusionDesired)\n        internal\n    {\n        /* CHECKS */\n\n        /* Assert sender is authorized to approve order. */\n        require(order.maker == msg.sender, \"Sender is not the maker of the order and thus not authorized to approve it\");\n\n        /* Calculate order hash. */\n        bytes32 hash = hashOrder(order);\n\n        /* Approve order hash. */\n        approveOrderHash(hash);\n\n        /* Log approval event. */\n        emit OrderApproved(hash, order.registry, order.maker, order.staticTarget, order.staticSelector, order.staticExtradata, order.maximumFill, order.listingTime, order.expirationTime, order.salt, orderbookInclusionDesired);\n    }\n\n    function setOrderFill(bytes32 hash, uint fill)\n        internal\n    {\n        /* CHECKS */\n\n        /* Assert fill is not already set. */\n        require(fills[msg.sender][hash] != fill, \"Fill is already set to the desired value\");\n\n        /* EFFECTS */\n\n        /* Mark order as accordingly filled. */\n        fills[msg.sender][hash] = fill;\n\n        /* Log order fill change event. */\n        emit OrderFillChanged(hash, msg.sender, fill);\n    }\n\n    function atomicMatch(Order memory firstOrder, Call memory firstCall, Order memory secondOrder, Call memory secondCall, bytes memory signatures, bytes32 metadata)\n        internal\n        reentrancyGuard\n    {\n        /* CHECKS */\n\n        /* Calculate first order hash. */\n        bytes32 firstHash = hashOrder(firstOrder);\n\n        /* Check first order validity. */\n        require(validateOrderParameters(firstOrder, firstHash), \"First order has invalid parameters\");\n\n        /* Calculate second order hash. */\n        bytes32 secondHash = hashOrder(secondOrder);\n\n        /* Check second order validity. */\n        require(validateOrderParameters(secondOrder, secondHash), \"Second order has invalid parameters\");\n\n        /* Prevent self-matching (possibly unnecessary, but safer). */\n        require(firstHash != secondHash, \"Self-matching orders is prohibited\");\n\n        {\n            /* Calculate signatures (must be awkwardly decoded here due to stack size constraints). */\n            (bytes memory firstSignature, bytes memory secondSignature) = abi.decode(signatures, (bytes, bytes));\n\n            /* Check first order authorization. */\n            require(validateOrderAuthorization(firstHash, firstOrder.maker, firstSignature), \"First order failed authorization\");\n\n            /* Check second order authorization. */\n            require(validateOrderAuthorization(secondHash, secondOrder.maker, secondSignature), \"Second order failed authorization\");\n        }\n\n        /* INTERACTIONS */\n\n        /* Transfer any msg.value.\n           This is the first \"asymmetric\" part of order matching: if an order requires Ether, it must be the first order. */\n        if (msg.value > 0) {\n            /* Reentrancy prevented by reentrancyGuard modifier */\n            (bool success,) = address(uint160(firstOrder.maker)).call{value: msg.value}(\"\");\n            require(success, \"native token transfer failed.\");\n        }\n\n        /* Execute first call, assert success.\n           This is the second \"asymmetric\" part of order matching: execution of the second order can depend on state changes in the first order, but not vice-versa. */\n        require(executeCall(ProxyRegistryInterface(firstOrder.registry), firstOrder.maker, firstCall), \"First call failed\");\n\n        /* Execute second call, assert success. */\n        require(executeCall(ProxyRegistryInterface(secondOrder.registry), secondOrder.maker, secondCall), \"Second call failed\");\n\n        /* Static calls must happen after the effectful calls so that they can check the resulting state. */\n\n        /* Fetch previous first order fill. */\n        uint previousFirstFill = fills[firstOrder.maker][firstHash];\n\n        /* Fetch previous second order fill. */\n        uint previousSecondFill = fills[secondOrder.maker][secondHash];\n\n        /* Execute first order static call, assert success, capture returned new fill. */\n        uint firstFill = executeStaticCall(firstOrder, firstCall, secondOrder, secondCall, msg.sender, msg.value, previousFirstFill);\n\n        /* Execute second order static call, assert success, capture returned new fill. */\n        uint secondFill = executeStaticCall(secondOrder, secondCall, firstOrder, firstCall, msg.sender, uint(0), previousSecondFill);\n\n        /* EFFECTS */\n\n        /* Update first order fill, if necessary. */\n        if (firstOrder.maker != msg.sender) {\n            if (firstFill != previousFirstFill) {\n                fills[firstOrder.maker][firstHash] = firstFill;\n            }\n        }\n\n        /* Update second order fill, if necessary. */\n        if (secondOrder.maker != msg.sender) {\n            if (secondFill != previousSecondFill) {\n                fills[secondOrder.maker][secondHash] = secondFill;\n            }\n        }\n\n        /* LOGS */\n\n        /* Log match event. */\n        emit OrdersMatched(firstHash, secondHash, firstOrder.maker, secondOrder.maker, firstFill, secondFill, metadata);\n    }\n\n}\n"
    },
    "openzeppelin-solidity/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/lib/StaticCaller.sol": {
      "content": "/*\n\n  << Static Caller >>\n\n*/\n\npragma solidity 0.7.5;\n\n/**\n * @title StaticCaller\n * @author Wyvern Protocol Developers\n */\ncontract StaticCaller {\n\n    function staticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bool result)\n    {\n        assembly {\n            result := staticcall(gas(), target, add(data, 0x20), mload(data), mload(0x40), 0)\n        }\n        return result;\n    }\n\n    function staticCallUint(address target, bytes memory data)\n        internal\n        view\n        returns (uint ret)\n    {\n        bool result;\n        assembly {\n            let size := 0x20\n            let free := mload(0x40)\n            result := staticcall(gas(), target, add(data, 0x20), mload(data), free, size)\n            ret := mload(free)\n        }\n        require(result, \"Static call failed\");\n        return ret;\n    }\n\n}\n"
    },
    "contracts/lib/ReentrancyGuarded.sol": {
      "content": "/*\n\n  Simple contract extension to provide a contract-global reentrancy guard on functions.\n\n*/\n\npragma solidity 0.7.5;\n\n/**\n * @title ReentrancyGuarded\n * @author Wyvern Protocol Developers\n */\ncontract ReentrancyGuarded {\n\n    bool reentrancyLock = false;\n\n    /* Prevent a contract function from being reentrant-called. */\n    modifier reentrancyGuard {\n        require(!reentrancyLock, \"Reentrancy detected\");\n        reentrancyLock = true;\n        _;\n        reentrancyLock = false;\n    }\n\n}\n"
    },
    "contracts/lib/EIP712.sol": {
      "content": "/*\n\n  << EIP 712 >>\n\n*/\n\npragma solidity 0.7.5;\n\n/**\n * @title EIP712\n * @author Wyvern Protocol Developers\n */\ncontract EIP712 {\n\n    struct EIP712Domain {\n        string  name;\n        string  version;\n        uint256 chainId;\n        address verifyingContract;\n    }\n\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    bytes32 DOMAIN_SEPARATOR;\n\n    function hash(EIP712Domain memory eip712Domain)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(\n            EIP712DOMAIN_TYPEHASH,\n            keccak256(bytes(eip712Domain.name)),\n            keccak256(bytes(eip712Domain.version)),\n            eip712Domain.chainId,\n            eip712Domain.verifyingContract\n        ));\n    }\n\n}\n"
    },
    "contracts/lib/EIP1271.sol": {
      "content": "/*\n\n  << EIP 1271 >>\n\n*/\n\npragma solidity 0.7.5;\n\nabstract contract ERC1271 {\n\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n  bytes4 constant internal MAGICVALUE = 0x1626ba7e;\n\n  /**\n   * @dev Should return whether the signature provided is valid for the provided hash\n   * @param _hash      Hash of the data to be signed\n   * @param _signature Signature byte array associated with _hash\n   *\n   * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n   * MUST allow external calls\n   */ \n  function isValidSignature(\n    bytes32 _hash, \n    bytes memory _signature)\n    virtual\n    public\n    view \n    returns (bytes4 magicValue);\n}"
    },
    "contracts/registry/ProxyRegistryInterface.sol": {
      "content": "/*\n\n  Proxy registry interface.\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"./OwnableDelegateProxy.sol\";\n\n/**\n * @title ProxyRegistryInterface\n * @author Wyvern Protocol Developers\n */\ninterface ProxyRegistryInterface {\n\n    function delegateProxyImplementation() external returns (address);\n\n    function proxies(address owner) external returns (OwnableDelegateProxy);\n\n}\n"
    },
    "contracts/registry/AuthenticatedProxy.sol": {
      "content": "/* \n\n  Proxy contract to hold access to assets on behalf of a user (e.g. ERC20 approve) and execute calls under particular conditions.\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"./ProxyRegistry.sol\";\nimport \"./TokenRecipient.sol\";\nimport \"./proxy/OwnedUpgradeabilityStorage.sol\";\n\n/**\n * @title AuthenticatedProxy\n * @author Wyvern Protocol Developers\n */\ncontract AuthenticatedProxy is TokenRecipient, OwnedUpgradeabilityStorage {\n\n    /* Whether initialized. */\n    bool initialized = false;\n\n    /* Address which owns this proxy. */\n    address public user;\n\n    /* Associated registry with contract authentication information. */\n    ProxyRegistry public registry;\n\n    /* Whether access has been revoked. */\n    bool public revoked;\n\n    /* Delegate call could be used to atomically transfer multiple assets owned by the proxy contract with one order. */\n    enum HowToCall { Call, DelegateCall }\n\n    /* Event fired when the proxy access is revoked or unrevoked. */\n    event Revoked(bool revoked);\n\n    /**\n     * Initialize an AuthenticatedProxy\n     *\n     * @param addrUser Address of user on whose behalf this proxy will act\n     * @param addrRegistry Address of ProxyRegistry contract which will manage this proxy\n     */\n    function initialize (address addrUser, ProxyRegistry addrRegistry)\n        public\n    {\n        require(!initialized, \"Authenticated proxy already initialized\");\n        initialized = true;\n        user = addrUser;\n        registry = addrRegistry;\n    }\n\n    /**\n     * Set the revoked flag (allows a user to revoke ProxyRegistry access)\n     *\n     * @dev Can be called by the user only\n     * @param revoke Whether or not to revoke access\n     */\n    function setRevoke(bool revoke)\n        public\n    {\n        require(msg.sender == user, \"Authenticated proxy can only be revoked by its user\");\n        revoked = revoke;\n        emit Revoked(revoke);\n    }\n\n    /**\n     * Execute a message call from the proxy contract\n     *\n     * @dev Can be called by the user, or by a contract authorized by the registry as long as the user has not revoked access\n     * @param dest Address to which the call will be sent\n     * @param howToCall Which kind of call to make\n     * @param data Calldata to send\n     * @return result Result of the call (success or failure)\n     */\n    function proxy(address dest, HowToCall howToCall, bytes memory data)\n        public\n        returns (bool result)\n    {\n        require(msg.sender == user || (!revoked && registry.contracts(msg.sender)), \"Authenticated proxy can only be called by its user, or by a contract authorized by the registry as long as the user has not revoked access\");\n        bytes memory ret;\n        if (howToCall == HowToCall.Call) {\n            (result, ret) = dest.call(data);\n        } else if (howToCall == HowToCall.DelegateCall) {\n            (result, ret) = dest.delegatecall(data);\n        }\n        return result;\n    }\n\n    /**\n     * Execute a message call and assert success\n     * \n     * @dev Same functionality as `proxy`, just asserts the return value\n     * @param dest Address to which the call will be sent\n     * @param howToCall What kind of call to make\n     * @param data Calldata to send\n     */\n    function proxyAssert(address dest, HowToCall howToCall, bytes memory data)\n        public\n    {\n        require(proxy(dest, howToCall, data), \"Proxy assertion failed\");\n    }\n\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/registry/OwnableDelegateProxy.sol": {
      "content": "/*\n\n  OwnableDelegateProxy\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"./proxy/OwnedUpgradeabilityProxy.sol\";\n\n/**\n * @title OwnableDelegateProxy\n * @author Wyvern Protocol Developers\n */\ncontract OwnableDelegateProxy is OwnedUpgradeabilityProxy {\n\n    constructor(address owner, address initialImplementation, bytes memory data)\n        public\n    {\n        setUpgradeabilityOwner(owner);\n        _upgradeTo(initialImplementation);\n        (bool success,) = initialImplementation.delegatecall(data);\n        require(success, \"OwnableDelegateProxy failed implementation\");\n    }\n\n}\n"
    },
    "contracts/registry/proxy/OwnedUpgradeabilityProxy.sol": {
      "content": "pragma solidity 0.7.5;\n\nimport \"./Proxy.sol\";\nimport \"./OwnedUpgradeabilityStorage.sol\";\n\n/**\n * @title OwnedUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n */\ncontract OwnedUpgradeabilityProxy is Proxy, OwnedUpgradeabilityStorage {\n    /**\n     * @dev Event to show ownership has been transferred\n     * @param previousOwner representing the address of the previous owner\n     * @param newOwner representing the address of the new owner\n     */\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n     * @dev This event will be emitted every time the implementation gets upgraded\n     * @param implementation representing the address of the upgraded implementation\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Tells the address of the current implementation\n     * @return address of the current implementation\n     */\n    function implementation() override public view returns (address) {\n        return _implementation;\n    }\n\n    /**\n     * @dev Tells the proxy type (EIP 897)\n     * @return proxyTypeId Proxy type, 2 for forwarding proxy\n     */\n    function proxyType() override public pure returns (uint256 proxyTypeId) {\n        return 2;\n    }\n\n    /**\n     * @dev Upgrades the implementation address\n     * @param implementation representing the address of the new implementation to be set\n     */\n    function _upgradeTo(address implementation) internal {\n        require(_implementation != implementation, \"Proxy already uses this implementation\");\n        _implementation = implementation;\n        emit Upgraded(implementation);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyProxyOwner() {\n        require(msg.sender == proxyOwner(), \"Only the proxy owner can call this method\");\n        _;\n    }\n\n    /**\n     * @dev Tells the address of the proxy owner\n     * @return the address of the proxy owner\n     */\n    function proxyOwner() public view returns (address) {\n        return upgradeabilityOwner();\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\n        require(newOwner != address(0), \"New owner cannot be the null address\");\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\n        setUpgradeabilityOwner(newOwner);\n    }\n\n    /**\n     * @dev Allows the upgradeability owner to upgrade the current implementation of the proxy.\n     * @param implementation representing the address of the new implementation to be set.\n     */\n    function upgradeTo(address implementation) public onlyProxyOwner {\n        _upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Allows the upgradeability owner to upgrade the current implementation of the proxy\n     * and delegatecall the new implementation for initialization.\n     * @param implementation representing the address of the new implementation to be set.\n     * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\n     * signature of the implementation to be called with the needed payload\n     */\n    function upgradeToAndCall(address implementation, bytes memory data) payable public onlyProxyOwner {\n        upgradeTo(implementation);\n        (bool success,) = address(this).delegatecall(data);\n        require(success, \"Call failed after proxy upgrade\");\n    }\n}\n"
    },
    "contracts/registry/proxy/Proxy.sol": {
      "content": "pragma solidity 0.7.5;\n\n/**\n * @title Proxy\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n */\nabstract contract Proxy {\n    /**\n     * @dev Tells the address of the implementation where every call will be delegated.\n     * @return address of the implementation to which it will be delegated\n     */\n    function implementation() virtual public view returns (address);\n\n    /**\n     * @dev Tells the type of proxy (EIP 897)\n     * @return proxyTypeId Type of proxy, 2 for upgradeable proxy\n     */\n    function proxyType() virtual public pure returns (uint256 proxyTypeId);\n\n    /**\n     * @dev Fallback function allowing to perform a delegatecall to the given implementation.\n     * This function will return whatever the implementation call returns\n     */\n    fallback () external payable {\n        address _impl = implementation();\n        require(_impl != address(0), \"Proxy implementation required\");\n\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n"
    },
    "contracts/registry/proxy/OwnedUpgradeabilityStorage.sol": {
      "content": "pragma solidity 0.7.5;\n\n/**\n * @title OwnedUpgradeabilityStorage\n * @dev This contract keeps track of the upgradeability owner\n */\ncontract OwnedUpgradeabilityStorage {\n\n    // Current implementation\n    address internal _implementation;\n\n    // Owner of the contract\n    address private _upgradeabilityOwner;\n\n    /**\n     * @dev Tells the address of the owner\n     * @return the address of the owner\n     */\n    function upgradeabilityOwner() public view returns (address) {\n        return _upgradeabilityOwner;\n    }\n\n    /**\n     * @dev Sets the address of the owner\n     */\n    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\n        _upgradeabilityOwner = newUpgradeabilityOwner;\n    }\n\n}\n"
    },
    "contracts/registry/ProxyRegistry.sol": {
      "content": "/*\n\n  Proxy registry; keeps a mapping of AuthenticatedProxy contracts and mapping of contracts authorized to access them.  \n  \n  Abstracted away from the Exchange (a) to reduce Exchange attack surface and (b) so that the Exchange contract can be upgraded without users needing to transfer assets to new proxies.\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/access/Ownable.sol\";\n\nimport \"./OwnableDelegateProxy.sol\";\nimport \"./ProxyRegistryInterface.sol\";\n\n/**\n * @title ProxyRegistry\n * @author Wyvern Protocol Developers\n */\ncontract ProxyRegistry is Ownable, ProxyRegistryInterface {\n\n    /* DelegateProxy implementation contract. Must be initialized. */\n    address public override delegateProxyImplementation;\n\n    /* Authenticated proxies by user. */\n    mapping(address => OwnableDelegateProxy) public override proxies;\n\n    /* Contracts pending access. */\n    mapping(address => uint) public pending;\n\n    /* Contracts allowed to call those proxies. */\n    mapping(address => bool) public contracts;\n\n    /* Delay period for adding an authenticated contract.\n       This mitigates a particular class of potential attack on the Wyvern DAO (which owns this registry) - if at any point the value of assets held by proxy contracts exceeded the value of half the WYV supply (votes in the DAO),\n       a malicious but rational attacker could buy half the Wyvern and grant themselves access to all the proxy contracts. A delay period renders this attack nonthreatening - given two weeks, if that happened, users would have\n       plenty of time to notice and transfer their assets.\n    */\n    //uint public DELAY_PERIOD = 2 weeks;\n    //TODO: updated\n    uint public DELAY_PERIOD = 0 weeks;\n\n    /**\n     * Start the process to enable access for specified contract. Subject to delay period.\n     *\n     * @dev ProxyRegistry owner only\n     * @param addr Address to which to grant permissions\n     */\n    function startGrantAuthentication (address addr)\n        public\n        onlyOwner\n    {\n        require(!contracts[addr] && pending[addr] == 0, \"Contract is already allowed in registry, or pending\");\n        pending[addr] = block.timestamp;\n    }\n\n    /**\n     * End the process to enable access for specified contract after delay period has passed.\n     *\n     * @dev ProxyRegistry owner only\n     * @param addr Address to which to grant permissions\n     */\n    function endGrantAuthentication (address addr)\n        public\n        onlyOwner\n    {\n        require(!contracts[addr] && pending[addr] != 0 && ((pending[addr] + DELAY_PERIOD) < block.timestamp), \"Contract is no longer pending or has already been approved by registry\");\n        pending[addr] = 0;\n        contracts[addr] = true;\n    }\n\n    /**\n     * Revoke access for specified contract. Can be done instantly.\n     *\n     * @dev ProxyRegistry owner only\n     * @param addr Address of which to revoke permissions\n     */    \n    function revokeAuthentication (address addr)\n        public\n        onlyOwner\n    {\n        contracts[addr] = false;\n    }\n\n    /**\n     * Register a proxy contract with this registry\n     *\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\n     * @return proxy New AuthenticatedProxy contract\n     */\n    function registerProxy()\n        public\n        returns (OwnableDelegateProxy proxy)\n    {\n        return registerProxyFor(msg.sender);\n    }\n\n    /**\n     * Register a proxy contract with this registry, overriding any existing proxy\n     *\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\n     * @return proxy New AuthenticatedProxy contract\n     */\n    function registerProxyOverride()\n        public\n        returns (OwnableDelegateProxy proxy)\n    {\n        proxy = new OwnableDelegateProxy(msg.sender, delegateProxyImplementation, abi.encodeWithSignature(\"initialize(address,address)\", msg.sender, address(this)));\n        proxies[msg.sender] = proxy;\n        return proxy;\n    }\n\n    /**\n     * Register a proxy contract with this registry\n     *\n     * @dev Can be called by any user\n     * @return proxy New AuthenticatedProxy contract\n     */\n    function registerProxyFor(address user)\n        public\n        returns (OwnableDelegateProxy proxy)\n    {\n        require(proxies[user] == OwnableDelegateProxy(0), \"User already has a proxy\");\n        proxy = new OwnableDelegateProxy(user, delegateProxyImplementation, abi.encodeWithSignature(\"initialize(address,address)\", user, address(this)));\n        proxies[user] = proxy;\n        return proxy;\n    }\n\n    /**\n     * Transfer access\n     */\n    function transferAccessTo(address from, address to)\n        public\n    {\n        OwnableDelegateProxy proxy = proxies[from];\n\n        /* CHECKS */\n        require(OwnableDelegateProxy(msg.sender) == proxy, \"Proxy transfer can only be called by the proxy\");\n        require(proxies[to] == OwnableDelegateProxy(0), \"Proxy transfer has existing proxy as destination\");\n\n        /* EFFECTS */\n        delete proxies[from];\n        proxies[to] = proxy;\n    }\n\n}\n"
    },
    "contracts/registry/TokenRecipient.sol": {
      "content": "/*\n\n  Token recipient. Modified very slightly from the example on http://ethereum.org/dao (just to index log parameters).\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title TokenRecipient\n * @author Wyvern Protocol Developers\n */\ncontract TokenRecipient {\n    event ReceivedEther(address indexed sender, uint amount);\n    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\n\n    /**\n     * @dev Receive tokens and generate a log event\n     * @param from Address from which to transfer tokens\n     * @param value Amount of tokens to transfer\n     * @param token Address of token\n     * @param extraData Additional data to log\n     */\n    function receiveApproval(address from, uint256 value, address token, bytes memory extraData) public {\n        ERC20 t = ERC20(token);\n        require(t.transferFrom(from, address(this), value), \"ERC20 token transfer failed\");\n        emit ReceivedTokens(from, value, token, extraData);\n    }\n\n    /**\n     * @dev Receive Ether and generate a log event\n     */\n    fallback () payable external {\n        emit ReceivedEther(msg.sender, msg.value);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/WyvernExchange.sol": {
      "content": "/*\n\n  << Wyvern Exchange >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"./exchange/Exchange.sol\";\n\n/**\n * @title WyvernExchange\n * @author Wyvern Protocol Developers\n */\ncontract WyvernExchange is Exchange {\n\n    string public constant name = \"Wyvern Exchange\";\n  \n    string public constant version = \"3.1\";\n\n    string public constant codename = \"Ancalagon\";\n\n    constructor (uint chainId, address[] memory registryAddrs, bytes memory customPersonalSignPrefix) public {\n        DOMAIN_SEPARATOR = hash(EIP712Domain({\n            name              : name,\n            version           : version,\n            chainId           : chainId,\n            verifyingContract : address(this)\n        }));\n        for (uint ind = 0; ind < registryAddrs.length; ind++) {\n          registries[registryAddrs[ind]] = true;\n        }\n        if (customPersonalSignPrefix.length > 0) {\n          personalSignPrefix = customPersonalSignPrefix;\n        }\n    }\n\n}\n"
    },
    "contracts/WyvernRegistry.sol": {
      "content": "/*\n\n  << Wyvern Proxy Registry >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"./registry/ProxyRegistry.sol\";\nimport \"./registry/AuthenticatedProxy.sol\";\n\n/**\n * @title WyvernRegistry\n * @author Wyvern Protocol Developers\n */\ncontract WyvernRegistry is ProxyRegistry {\n\n    string public constant name = \"Wyvern Protocol Proxy Registry\";\n\n    /* Whether the initial auth address has been set. */\n    bool public initialAddressSet = false;\n\n    constructor ()\n        public\n    {   \n        AuthenticatedProxy impl = new AuthenticatedProxy();\n        impl.initialize(address(this), this);\n        impl.setRevoke(true);\n        delegateProxyImplementation = address(impl);\n    }   \n\n    /** \n     * Grant authentication to the initial Exchange protocol contract\n     *\n     * @dev No delay, can only be called once - after that the standard registry process with a delay must be used\n     * @param authAddress Address of the contract to grant authentication\n     */\n    function grantInitialAuthentication (address authAddress)\n        onlyOwner\n        public\n    {   \n        require(!initialAddressSet, \"Wyvern Protocol Proxy Registry initial address already set\");\n        initialAddressSet = true;\n        contracts[authAddress] = true;\n    }   \n\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view virtual returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId); // internal owner\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); // internal owner\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "openzeppelin-solidity/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, \"EnumerableMap: nonexistent key\"); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/TestSmartContractWallet.sol": {
      "content": "/*\n  << TestSmartContractWallet >>\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\";\n\ncontract ExchangeInterface{\n    function approveOrder_(address registry, address maker, address staticTarget, bytes4 staticSelector, bytes calldata staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired)\n    external{}\n}\ncontract ProxyInterface{\n    function registerProxy()\n    external{}\n}\n\n/**\n * @title TestSmartContractWallet\n * @dev Test contract for Smart contract wallets, proxies some calls an EOA wallet would make to setup on wyvern.\n */\ncontract TestSmartContractWallet {\n\n    event Deposit(address indexed _from, uint indexed _id, uint _value);\n\n    constructor () public {\n    }\n\n    // Called by atomicMatch when this contract is taker for an order with eth value exchanged.\n    receive() external payable {\n        // Use more than 2300 gas to test gas limit for send and transfer\n        emit Deposit(msg.sender, 0, msg.value);\n        emit Deposit(msg.sender, 1, msg.value);\n        emit Deposit(msg.sender, 2, msg.value);\n    }\n\n    // Proxy to exchange\n    function approveOrder_(address exchange, address registry, address maker, address staticTarget, bytes4 staticSelector, bytes calldata staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired)\n    public returns (bool) {\n        ExchangeInterface(exchange).approveOrder_(registry, maker, staticTarget, staticSelector, staticExtradata, maximumFill, listingTime, expirationTime, salt, orderbookInclusionDesired);\n        return true;\n    }\n\n    // Proxy to registry\n    function registerProxy(address registry)\n    public returns (bool) {\n        ProxyInterface(registry).registerProxy();\n        return true;\n    }\n\n    // Proxy to erc721\n    function setApprovalForAll(address registry, address erc721, bool approved)\n    public returns (bool) {\n        ERC721(erc721).setApprovalForAll(registry, approved);\n        return true;\n    }\n}\n"
    },
    "contracts/TestERC721.sol": {
      "content": "/*\n\n  << TestERC721 >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\";\n\ncontract TestERC721 is ERC721(\"test\", \"TST\") {\n\n    /**\n     */\n    constructor () public {\n        mint(msg.sender, 1);\n        mint(msg.sender, 2);\n        mint(msg.sender, 3);\n    }\n\n    /**\n     */\n    function mint(address to, uint256 tokenId) public returns (bool) {\n        _mint(to, tokenId);\n        return true;\n    }\n\n}\n"
    },
    "contracts/TestERC3525/VNFTCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC721/ERC721Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/EnumerableSet.sol\";\nimport \"./interface/IVNFT.sol\";\nimport \"./library/AssetLibrary.sol\";\n\nabstract contract VNFTCore is IVNFT, ERC721 {\n    using SafeMath for uint256;\n    using AssetLibrary for AssetLibrary.Asset;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    event Mint(\n        address indexed minter,\n        uint256 indexed tokenId,\n        uint256 indexed slot,\n        uint256 units\n    );\n    event Burn(address indexed owner, uint256 indexed tokenId, uint256 units);\n\n    struct ApproveUnits {\n        bool isValid;\n        mapping(address => uint256) approvals;\n    }\n\n    bytes4 private constant _VNFT_RECEIVED = 0xb382cdcd;\n\n    //@dev The mapping of tokenId\n    mapping(uint256 => AssetLibrary.Asset) public assets;\n\n    //owner => tokenId => operator => units\n    mapping(address => mapping(uint256 => ApproveUnits))\n        private _tokenApprovalUnits;\n\n    //slot => tokenIds\n    mapping(uint256 => EnumerableSet.UintSet) private _slotTokens;\n\n    string private _contractURI;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        string memory baseURI_,\n        string memory contractURI_\n    ) ERC721(name_, symbol_) {\n        ERC721._setBaseURI(baseURI_);\n        _contractURI = contractURI_;\n    }\n\n   function _setContractURI(string memory uri_) internal {\n        _contractURI = uri_;\n    }\n\n    function contractURI() public view returns (string memory) {\n        return _contractURI;\n    }\n\n    function _safeTransferUnitsFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_,\n        bytes memory data_\n    ) internal virtual {\n        _transferUnitsFrom(\n            from_,\n            to_,\n            tokenId_,\n            targetTokenId_,\n            transferUnits_\n        );\n        require(\n            _checkOnVNFTReceived(\n                from_,\n                to_,\n                targetTokenId_,\n                transferUnits_,\n                data_\n            ),\n            \"to non VNFTReceiver implementer\"\n        );\n    }\n\n    function _transferUnitsFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_\n    ) internal virtual {\n        require(from_ == ownerOf(tokenId_), \"source token owner mismatch\");\n\n        //approve all后可不需要approve units\n        if (_msgSender() != from_ && !isApprovedForAll(from_, _msgSender())) {\n            _tokenApprovalUnits[from_][tokenId_].approvals[\n                    _msgSender()\n                ] = _tokenApprovalUnits[from_][tokenId_]\n                .approvals[_msgSender()]\n                .sub(transferUnits_, \"transfer units exceeds allowance\");\n        }\n\n        require(to_ != address(0), \"transfer to the zero address\");\n\n        if (!_exists(targetTokenId_)) {\n            ERC721._mint(to_, targetTokenId_);\n        } else {\n            require(\n                ownerOf(targetTokenId_) == to_,\n                \"target token owner mismatch\"\n            );\n        }\n\n        assets[tokenId_].transfer(assets[targetTokenId_], transferUnits_);\n\n        emit PartialTransfer(\n            from_,\n            to_,\n            tokenId_,\n            targetTokenId_,\n            transferUnits_\n        );\n    }\n\n    function _merge(uint256 tokenId_, uint256 targetTokenId_) internal virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId_),\n            \"VNFT: not owner nor approved\"\n        );\n        require(_exists(targetTokenId_), \"target token not exists\");\n        require(tokenId_ != targetTokenId_, \"self merge not allowed\");\n\n        address owner = ownerOf(tokenId_);\n        require(owner == ownerOf(targetTokenId_), \"not same owner\");\n\n        uint256 mergeUnits = assets[tokenId_].merge(assets[targetTokenId_]);\n        _burn(tokenId_);\n\n        emit Merge(owner, tokenId_, targetTokenId_, mergeUnits);\n    }\n\n    function _splitUnits(\n        uint256 tokenId_,\n        uint256 newTokenId_,\n        uint256 splitUnits_\n    ) internal virtual {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId_),\n            \"VNFT: not owner nor approved\"\n        );\n        require(!_exists(newTokenId_), \"new token already exists\");\n\n        assets[tokenId_].units = assets[tokenId_].units.sub(splitUnits_);\n\n        address owner = ownerOf(tokenId_);\n        _mintUnits(owner, newTokenId_, assets[tokenId_].slot, splitUnits_);\n\n        emit Split(owner, tokenId_, newTokenId_, splitUnits_);\n    }\n\n    function approve(\n        address to,\n        uint256 tokenId,\n        uint256 units\n    ) public virtual override {\n        _approveUnits(_msgSender(), to, tokenId, units);\n    }\n\n    function _mintUnits(\n        address minter_,\n        uint256 tokenId_,\n        uint256 slot_,\n        uint256 units_\n    ) internal virtual {\n        if (!_exists(tokenId_)) {\n            ERC721._mint(minter_, tokenId_);\n        }\n\n        assets[tokenId_].mint(slot_, units_);\n        if (!_slotTokens[slot_].contains(tokenId_)) {\n            _slotTokens[slot_].add(tokenId_);\n        }\n\n        emit Mint(minter_, tokenId_, slot_, units_);\n    }\n\n    function _exists(uint256 tokenId_)\n        internal\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return ERC721._exists(tokenId_);\n    }\n\n    function _burn(uint256 tokenId_) internal virtual override {\n        uint256 units = assets[tokenId_].units;\n        address owner = ownerOf(tokenId_);\n        uint256 slot = assets[tokenId_].slot;\n        if (_slotTokens[slot].contains(tokenId_)) {\n            _slotTokens[slot].remove(tokenId_);\n        }\n        delete assets[tokenId_];\n        delete _tokenApprovalUnits[owner][tokenId_];\n        ERC721._burn(tokenId_);\n        emit Burn(owner, tokenId_, units);\n    }\n\n    function _burnUnits(uint256 tokenId_, uint256 burnUnits_)\n        internal\n        virtual\n        returns (uint256 balance)\n    {\n        address owner = ownerOf(tokenId_);\n        assets[tokenId_].burn(burnUnits_);\n\n        emit Burn(owner, tokenId_, burnUnits_);\n\n        return assets[tokenId_].units;\n    }\n\n    function _approveUnits(\n        address owner,\n        address to,\n        uint256 tokenId,\n        uint256 units\n    ) internal virtual {\n        require(owner == ownerOf(tokenId), \"VNFT: only owner\");\n        _tokenApprovalUnits[owner][tokenId].isValid = true;\n        _tokenApprovalUnits[owner][tokenId].approvals[to] = units;\n        emit ApprovalUnits(owner, to, tokenId, units);\n    }\n\n    function allowance(uint256 tokenId, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        address owner = ownerOf(tokenId);\n        return _tokenApprovalUnits[owner][tokenId].approvals[spender];\n    }\n\n    function unitsInToken(uint256 tokenId_)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return assets[tokenId_].units;\n    }\n\n    function balanceOfSlot(uint256 slot)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _slotTokens[slot].length();\n    }\n\n    function tokenOfSlotByIndex(uint256 slot, uint256 index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _slotTokens[slot].at(index);\n    }\n\n    function slotOf(uint256 tokenId_) public view override returns (uint256) {\n        return assets[tokenId_].slot;\n    }\n\n    function isValid(uint256 tokenId_) public view returns (bool) {\n        return assets[tokenId_].isValid;\n    }\n\n    function _checkOnVNFTReceived(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 units_,\n        bytes memory _data\n    ) internal returns (bool) {\n        if (!to_.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to_.functionCall(\n            abi.encodeWithSelector(\n                IVNFTReceiver(to_).onVNFTReceived.selector,\n                _msgSender(),\n                from_,\n                tokenId_,\n                units_,\n                _data\n            ),\n            \"non VNFTReceiver implementer\"\n        );\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _VNFT_RECEIVED);\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC721/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./ERC721.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/TestERC3525/interface/IVNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\ninterface IVNFT /* is IERC721 */{\n    event PartialTransfer(address indexed from, address indexed to, uint256 indexed tokenId, uint256 targetTokenId,\n        uint256 transferUnits);\n    event Split(address indexed owner, uint256 indexed tokenId, uint256 newTokenId, uint256 splitUnits);\n    event Merge(address indexed owner, uint256 indexed tokenId, uint256 indexed targetTokenId, uint256 mergeUnits);\n    event ApprovalUnits(address indexed owner, address indexed approved, uint256 indexed tokenId, uint256 approvalUnits);\n\n    function slotOf(uint256 tokenId)  external view returns(uint256 slot);\n\n    function balanceOfSlot(uint256 slot) external view returns (uint256 balance);\n    function tokenOfSlotByIndex(uint256 slot, uint256 index) external view returns (uint256 tokenId);\n    function unitsInToken(uint256 tokenId) external view returns (uint256 units);\n\n    function approve(address to, uint256 tokenId, uint256 units) external;\n    function allowance(uint256 tokenId, address spender) external view returns (uint256 allowed);\n\n    function split(uint256 tokenId, uint256[] calldata units) external returns (uint256[] memory newTokenIds);\n    function merge(uint256[] calldata tokenIds, uint256 targetTokenId) external;\n\n    function transferFrom(address from, address to, uint256 tokenId,\n        uint256 units) external returns (uint256 newTokenId);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId,\n        uint256 units, bytes calldata data) external returns (uint256 newTokenId);\n\n    function transferFrom(address from, address to, uint256 tokenId, uint256 targetTokenId,\n        uint256 units) external;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, uint256 targetTokenId,\n        uint256 units, bytes calldata data) external;\n}\n\ninterface IVNFTReceiver {\n    function onVNFTReceived(address operator, address from, uint256 tokenId,\n        uint256 units, bytes calldata data) external returns (bytes4);\n}"
    },
    "contracts/TestERC3525/library/AssetLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n//@title 资产相关结构及逻辑库\nlibrary AssetLibrary {\n    using SafeMath for uint256;\n\n    struct Asset {\n        uint256 slot; //标识资产的分类\n        uint256 units; //资产份数\n        bool isValid; //是否有效\n    }\n\n    //@notice 增加Vault的份额\n    //@dev\n    //@param self 需要增加份额的Vault的引用\n    //@param slot\n    function mint(Asset storage self, uint256 slot, uint256 units) internal {\n        if (! self.isValid) {\n            self.slot = slot;\n            self.isValid = true;\n        } else {\n            require(self.slot == slot, \"slot mismatch\");\n        }\n        self.units = self.units.add(units);\n    }\n\n    function merge(Asset storage self, Asset storage target) internal returns (uint256){\n        require(self.isValid && target.isValid, \"asset not exists\");\n        require(self.slot == target.slot, \"slot mismatch\");\n\n        uint256 mergeUnits = self.units;\n        self.units = self.units.sub(mergeUnits, \"merge excess units\");\n        target.units = target.units.add(mergeUnits);\n        self.isValid = false;\n\n        return (mergeUnits);\n    }\n\n    function transfer(Asset storage self, Asset storage target, uint256 units) internal {\n        require(self.isValid, \"asset not exists\");\n        self.units = self.units.sub(units, \"transfer excess units\");\n        if (target.isValid) {\n            require(self.slot == target.slot, \"slot mismatch\");\n        } else {\n            target.slot = self.slot;\n            target.isValid = true;\n        }\n\n        target.units = target.units.add(units);\n    }\n\n    function burn(Asset storage self, uint256 units) internal {\n        self.units = self.units.sub(units, \"burn excess units\");\n\n    }\n}"
    },
    "openzeppelin-solidity/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155MetadataURI.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor (string memory uri_) public {\n        _setURI(uri_);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(\n            amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC1155/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "contracts/TestERC1155.sol": {
      "content": "/*\n\n  << TestERC1155 >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract TestERC1155 is ERC1155(\"http://test/{id}.json\") {\n\n\t/**\n\t */\n\tconstructor () public {\n\t}\n\n\tfunction mint(address to, uint256 tokenId) public returns (bool) {\n\t\t_mint(to, tokenId, 1, \"\");\n\t\treturn true;\n\t}\n\n\tfunction mint(address to, uint256 tokenId, uint256 amount) public returns (bool) {\n\t\t_mint(to, tokenId, amount, \"\");\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/static/StaticERC721.sol": {
      "content": "/*\n\n    StaticERC721 - static calls for ERC721 trades\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"../lib/ArrayUtils.sol\";\nimport \"../registry/AuthenticatedProxy.sol\";\n\ncontract StaticERC721 {\n\n    function transferERC721Exact(bytes memory extra,\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\n        bytes memory data)\n        public\n        pure\n    {\n        // Decode extradata\n        (address token, uint tokenId) = abi.decode(extra, (address, uint));\n\n        // Call target = token to give\n        require(addresses[2] == token);\n        // Call type = call\n        require(howToCall == AuthenticatedProxy.HowToCall.Call);\n        // Assert calldata\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], tokenId)));\n    }\n\n    function swapOneForOneERC721(bytes memory extra,\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n        bytes memory data, bytes memory counterdata)\n        public\n        pure\n        returns (uint)\n    {\n        // Zero-value\n        require(uints[0] == 0);\n\n        // Decode extradata\n        (address[2] memory tokenGiveGet, uint[2] memory nftGiveGet) = abi.decode(extra, (address[2],uint[2]));\n\n        // Call target = token to give\n        require(addresses[2] == tokenGiveGet[0], \"ERC721: call target must equal address of token to give\");\n        // Call type = call\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC721: call must be a direct call\");\n        // Assert calldata\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], nftGiveGet[0])));\n\n        // Countercall target = token to get\n        require(addresses[5] == tokenGiveGet[1], \"ERC721: countercall target must equal address of token to get\");\n        // Countercall type = call\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC721: countercall must be a direct call\");\n        // Assert countercalldata\n        require(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[4], addresses[1], nftGiveGet[1])));\n\n        // Mark filled\n        return 1;\n    }\n\n    function swapOneForOneERC721Decoding(bytes memory extra,\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n        bytes memory data, bytes memory counterdata)\n        public\n        pure\n        returns (uint)\n    {\n        // Calculate function signature\n        bytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\"), 4);\n\n        // Zero-value\n        require(uints[0] == 0);\n\n        // Decode extradata\n        (address[2] memory tokenGiveGet, uint[2] memory nftGiveGet) = abi.decode(extra, (address[2],uint[2]));\n\n        // Call target = token to give\n        require(addresses[2] == tokenGiveGet[0], \"ERC721: call target must equal address of token to give\");\n        // Call type = call\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC721: call must be a direct call\");\n        // Assert signature\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\n        // Decode calldata\n        (address callFrom, address callTo, uint256 nftGive) = abi.decode(ArrayUtils.arrayDrop(data, 4), (address, address, uint256));\n        // Assert from\n        require(callFrom == addresses[1]);\n        // Assert to\n        require(callTo == addresses[4]);\n        // Assert NFT\n        require(nftGive == nftGiveGet[0]);\n\n        // Countercall target = token to get\n        require(addresses[5] == tokenGiveGet[1], \"ERC721: countercall target must equal address of token to get\");\n        // Countercall type = call\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC721: countercall must be a direct call\");\n        // Assert signature\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(counterdata, 4)));\n        // Decode countercalldata\n        (address countercallFrom, address countercallTo, uint256 nftGet) = abi.decode(ArrayUtils.arrayDrop(counterdata, 4), (address, address, uint256));\n        // Assert from\n        require(countercallFrom == addresses[4]);\n        // Assert to\n        require(countercallTo == addresses[1]);\n        // Assert NFT\n        require(nftGet == nftGiveGet[1]);\n\n        // Mark filled\n        return 1;\n    }\n\n}\n"
    },
    "contracts/lib/ArrayUtils.sol": {
      "content": "/*\n\n  << ArrayUtils >>\n\n  Various functions for manipulating arrays in Solidity.\n  This library is completely inlined and does not need to be deployed or linked.\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title ArrayUtils\n * @author Wyvern Protocol Developers\n */\nlibrary ArrayUtils {\n\n    /**\n     * Replace bytes in an array with bytes in another array, guarded by a bitmask\n     * Efficiency of this function is a bit unpredictable because of the EVM's word-specific model (arrays under 32 bytes will be slower)\n     * Modifies the provided byte array parameter in place\n     * \n     * @dev Mask must be the size of the byte array. A nonzero byte means the byte array can be changed.\n     * @param array The original array\n     * @param desired The target array\n     * @param mask The mask specifying which bits can be changed\n     */\n    function guardedArrayReplace(bytes memory array, bytes memory desired, bytes memory mask)\n        internal\n        pure\n    {\n        require(array.length == desired.length, \"Arrays have different lengths\");\n        require(array.length == mask.length, \"Array and mask have different lengths\");\n\n        uint words = array.length / 0x20;\n        uint index = words * 0x20;\n        assert(index / 0x20 == words);\n        uint i;\n\n        for (i = 0; i < words; i++) {\n            /* Conceptually: array[i] = (!mask[i] && array[i]) || (mask[i] && desired[i]), bitwise in word chunks. */\n            assembly {\n                let commonIndex := mul(0x20, add(1, i))\n                let maskValue := mload(add(mask, commonIndex))\n                mstore(add(array, commonIndex), or(and(not(maskValue), mload(add(array, commonIndex))), and(maskValue, mload(add(desired, commonIndex)))))\n            }\n        }\n\n        /* Deal with the last section of the byte array. */\n        if (words > 0) {\n            /* This overlaps with bytes already set but is still more efficient than iterating through each of the remaining bytes individually. */\n            i = words;\n            assembly {\n                let commonIndex := mul(0x20, add(1, i))\n                let maskValue := mload(add(mask, commonIndex))\n                mstore(add(array, commonIndex), or(and(not(maskValue), mload(add(array, commonIndex))), and(maskValue, mload(add(desired, commonIndex)))))\n            }\n        } else {\n            /* If the byte array is shorter than a word, we must unfortunately do the whole thing bytewise.\n               (bounds checks could still probably be optimized away in assembly, but this is a rare case) */\n            for (i = index; i < array.length; i++) {\n                array[i] = ((mask[i] ^ 0xff) & array[i]) | (mask[i] & desired[i]);\n            }\n        }\n    }\n\n    /**\n     * Test if two arrays are equal\n     * Source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n     * \n     * @dev Arrays must be of equal length, otherwise will return false\n     * @param a First array\n     * @param b Second array\n     * @return Whether or not all bytes in the arrays are equal\n     */\n    function arrayEq(bytes memory a, bytes memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            let length := mload(a)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(b))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(a, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(b, 0x20)\n                // the next line is the loop condition:\n                // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    /**\n     * Drop the beginning of an array\n     *\n     * @param _bytes array\n     * @param _start start index\n     * @return Whether or not all bytes in the arrays are equal\n     */\n    function arrayDrop(bytes memory _bytes, uint _start)\n        internal\n        pure\n        returns (bytes memory)\n    {\n\n        uint _length = SafeMath.sub(_bytes.length, _start);\n        return arraySlice(_bytes, _start, _length);\n    }\n\n    /**\n     * Take from the beginning of an array\n     *\n     * @param _bytes array\n     * @param _length elements to take\n     * @return Whether or not all bytes in the arrays are equal\n     */\n    function arrayTake(bytes memory _bytes, uint _length)\n        internal\n        pure\n        returns (bytes memory)\n    {\n\n        return arraySlice(_bytes, 0, _length);\n    }\n\n    /**\n     * Slice an array\n     * Source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n     *\n     * @param _bytes array\n     * @param _start start index\n     * @param _length length to take\n     * @return Whether or not all bytes in the arrays are equal\n     */\n    function arraySlice(bytes memory _bytes, uint _start, uint _length)\n        internal\n        pure\n        returns (bytes memory)\n    {\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * Unsafe write byte array into a memory location\n     *\n     * @param index Memory location\n     * @param source Byte array to write\n     * @return End memory index\n     */\n    function unsafeWriteBytes(uint index, bytes memory source)\n        internal\n        pure\n        returns (uint)\n    {\n        if (source.length > 0) {\n            assembly {\n                let length := mload(source)\n                let end := add(source, add(0x20, length))\n                let arrIndex := add(source, 0x20)\n                let tempIndex := index\n                for { } eq(lt(arrIndex, end), 1) {\n                    arrIndex := add(arrIndex, 0x20)\n                    tempIndex := add(tempIndex, 0x20)\n                } {\n                    mstore(tempIndex, mload(arrIndex))\n                }\n                index := add(index, length)\n            }\n        }\n        return index;\n    }\n\n    /**\n     * Unsafe write address into a memory location\n     *\n     * @param index Memory location\n     * @param source Address to write\n     * @return End memory index\n     */\n    function unsafeWriteAddress(uint index, address source)\n        internal\n        pure\n        returns (uint)\n    {\n        uint conv = uint(source) << 0x60;\n        assembly {\n            mstore(index, conv)\n            index := add(index, 0x14)\n        }\n        return index;\n    }\n\n    /**\n     * Unsafe write uint into a memory location\n     *\n     * @param index Memory location\n     * @param source uint to write\n     * @return End memory index\n     */\n    function unsafeWriteUint(uint index, uint source)\n        internal\n        pure\n        returns (uint)\n    {\n        assembly {\n            mstore(index, source)\n            index := add(index, 0x20)\n        }\n        return index;\n    }\n\n    /**\n     * Unsafe write uint8 into a memory location\n     *\n     * @param index Memory location\n     * @param source uint8 to write\n     * @return End memory index\n     */\n    function unsafeWriteUint8(uint index, uint8 source)\n        internal\n        pure\n        returns (uint)\n    {\n        assembly {\n            mstore8(index, source)\n            index := add(index, 0x1)\n        }\n        return index;\n    }\n\n}\n"
    },
    "contracts/WyvernStatic.sol": {
      "content": "/*\n\n  << Wyvern Static >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"./static/StaticERC20.sol\";\nimport \"./static/StaticERC721.sol\";\nimport \"./static/StaticERC1155.sol\";\nimport \"./static/StaticERC3525.sol\";\nimport \"./static/StaticUtil.sol\";\n\n/**\n * @title WyvernStatic\n * @author Wyvern Protocol Developers\n */\ncontract WyvernStatic is StaticERC20, StaticERC721, StaticERC1155, StaticERC3525, StaticUtil {\n\n    string public constant name = \"Wyvern Static\";\n\n    constructor (address atomicizerAddress)\n        public\n    {\n        atomicizer = atomicizerAddress;\n    }\n\n    function test () \n        public\n        pure\n    {\n    }\n\n}\n"
    },
    "contracts/static/StaticERC20.sol": {
      "content": "/*\n\n    StaticERC20 - static calls for ERC20 trades\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"../lib/ArrayUtils.sol\";\nimport \"../registry/AuthenticatedProxy.sol\";\n\ncontract StaticERC20 {\n\n    function transferERC20Exact(bytes memory extra,\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\n        bytes memory data)\n        public\n        pure\n    {\n        // Decode extradata\n        (address token, uint amount) = abi.decode(extra, (address, uint));\n\n        // Call target = token to give\n        require(addresses[2] == token);\n        // Call type = call\n        require(howToCall == AuthenticatedProxy.HowToCall.Call);\n        // Assert calldata\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], amount)));\n    }\n\n    function swapExact(bytes memory extra,\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n        bytes memory data, bytes memory counterdata)\n        public\n        pure\n        returns (uint)\n    {\n        // Zero-value\n        require(uints[0] == 0);\n\n        // Decode extradata\n        (address[2] memory tokenGiveGet, uint[2] memory amountGiveGet) = abi.decode(extra, (address[2], uint[2]));\n\n        // Call target = token to give\n        require(addresses[2] == tokenGiveGet[0]);\n        // Call type = call\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call);\n        // Assert calldata\n        require(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[1], addresses[4], amountGiveGet[0])));\n\n        require(addresses[5] == tokenGiveGet[1]);\n        // Countercall type = call\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call);\n        // Assert countercalldata\n        require(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", addresses[4], addresses[1], amountGiveGet[1])));\n\n        // Mark filled.\n        return 1;\n    }\n\n    function swapForever(bytes memory extra,\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n        bytes memory data, bytes memory counterdata)\n        public\n        pure\n        returns (uint)\n    {\n        // Calculate function signature\n        bytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\"), 4);\n\n        // Zero-value\n        require(uints[0] == 0);\n\n        // Decode extradata\n        (address[2] memory tokenGiveGet, uint[2] memory numeratorDenominator) = abi.decode(extra, (address[2], uint[2]));\n\n        // Call target = token to give\n        require(addresses[2] == tokenGiveGet[0]);\n        // Call type = call\n        require(howToCalls[0] == AuthenticatedProxy.HowToCall.Call);\n        // Check signature\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\n        // Decode calldata\n        (address callFrom, address callTo, uint256 amountGive) = abi.decode(ArrayUtils.arrayDrop(data, 4), (address, address, uint256));\n        // Assert from\n        require(callFrom == addresses[1]);\n        // Assert to\n        require(callTo == addresses[4]);\n\n        // Countercall target = token to get\n        require(addresses[5] == tokenGiveGet[1]);\n        // Countercall type = call\n        require(howToCalls[1] == AuthenticatedProxy.HowToCall.Call);\n        // Check signature\n        require(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(counterdata, 4)));\n        // Decode countercalldata\n        (address countercallFrom, address countercallTo, uint256 amountGet) = abi.decode(ArrayUtils.arrayDrop(counterdata, 4), (address, address, uint256));\n        // Assert from\n        require(countercallFrom == addresses[4]);\n        // Assert to\n        require(countercallTo == addresses[1]);\n\n        // Assert ratio\n        // ratio = min get/give\n        require(SafeMath.mul(amountGet, numeratorDenominator[1]) >= SafeMath.mul(amountGive, numeratorDenominator[0]));\n\n        // Order will be set with maximumFill = 2 (to allow signature caching)\n        return 1;\n    }\n\n\n}\n"
    },
    "contracts/static/StaticERC1155.sol": {
      "content": "/*\n\nStaticERC1155 - static calls for ERC1155 trades\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"../lib/ArrayUtils.sol\";\nimport \"../registry/AuthenticatedProxy.sol\";\n\ncontract StaticERC1155 {\n\nfunction transferERC1155Exact(bytes memory extra,\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\n\tbytes memory data)\n\tpublic\n\tpure\n{\n\t// Decode extradata\n\t(address token, uint256 tokenId, uint256 amount) = abi.decode(extra, (address, uint256, uint256));\n\n\t// Call target = token to give\n\trequire(addresses[2] == token);\n\t// Call type = call\n\trequire(howToCall == AuthenticatedProxy.HowToCall.Call);\n\t// Assert calldata\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], tokenId, amount, \"\")));\n}\n\nfunction swapOneForOneERC1155(bytes memory extra,\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n\tbytes memory data, bytes memory counterdata)\n\tpublic\n\tpure\n\treturns (uint)\n{\n\t// Zero-value\n\trequire(uints[0] == 0);\n\n\t// Decode extradata\n\t(address[2] memory tokenGiveGet, uint256[2] memory nftGiveGet, uint256[2] memory nftAmounts) = abi.decode(extra, (address[2], uint256[2], uint256[2]));\n\n\t// Call target = token to give\n\trequire(addresses[2] == tokenGiveGet[0], \"ERC1155: call target must equal address of token to give\");\n\t// Assert more than zero\n\trequire(nftAmounts[0] > 0,\"ERC1155: give amount must be larger than zero\");\n\t// Call type = call\n\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC1155: call must be a direct call\");\n\t// Assert calldata\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], nftGiveGet[0], nftAmounts[0], \"\")));\n\n\t// Countercall target = token to get\n\trequire(addresses[5] == tokenGiveGet[1], \"ERC1155: countercall target must equal address of token to get\");\n\t// Assert more than zero\n\trequire(nftAmounts[1] > 0,\"ERC1155: take amount must be larger than zero\");\n\t// Countercall type = call\n\trequire(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC1155: countercall must be a direct call\");\n\t// Assert countercalldata\n\trequire(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[4], addresses[1], nftGiveGet[1], nftAmounts[1], \"\")));\n\n\t// Mark filled\n\treturn 1;\n}\n\nfunction swapOneForOneERC1155Decoding(bytes memory extra,\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n\tbytes memory data, bytes memory counterdata)\n\tpublic\n\tpure\n\treturns (uint)\n{\n\t// Calculate function signature\n\tbytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"), 4);\n\n\t// Zero-value\n\trequire(uints[0] == 0);\n\n\t// Decode extradata\n\t(address[2] memory tokenGiveGet, uint256[2] memory nftGiveGet, uint256[2] memory nftAmounts) = abi.decode(extra, (address[2],uint256[2],uint256[2]));\n\n\t// Call target = token to give\n\trequire(addresses[2] == tokenGiveGet[0], \"ERC1155: call target must equal address of token to give\");\n\t// Call type = call\n\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC1155: call must be a direct call\");\n\t// Assert signature\n\trequire(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\n\t// Decode and assert calldata\t\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], nftGiveGet[0], nftAmounts[0], \"\")));\n\t// Decode and assert countercalldata\n\trequire(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[4], addresses[1], nftGiveGet[1], nftAmounts[1], \"\")));\n\n\t// Mark filled\n\treturn 1;\n}\n\n}\n"
    },
    "contracts/static/StaticERC3525.sol": {
      "content": "/*\n\nStaticERC3525 - static calls for ERC3525 trades\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"../lib/ArrayUtils.sol\";\nimport \"../registry/AuthenticatedProxy.sol\";\n\ncontract StaticERC3525 {\n\nfunction transferERC3525Exact(bytes memory extra,\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory,\n\tbytes memory data)\n\tpublic\n\tpure\n{\n\t// Decode extradata (to, tokenId, value)\n\t(address token, uint256 tokenId, uint256 amount) = abi.decode(extra, (address, uint256, uint256));\n\n\t// Call target = token to give\n\trequire(addresses[2] == token);\n\t// Call type = call\n\trequire(howToCall == AuthenticatedProxy.HowToCall.Call);\n\t// Assert calldata\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], tokenId, amount, \"\")));\n}\n\nfunction swapOneForOneERC3525(bytes memory extra,\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n\tbytes memory data, bytes memory counterdata)\n\tpublic\n\tpure\n\treturns (uint)\n{\n\t// Zero-value\n\trequire(uints[0] == 0);\n\n\t// Decode extradata\n\t(address[2] memory tokenGiveGet, uint256[2] memory voucherGiveGet, uint256[2] memory transferValues) = abi.decode(extra, (address[2], uint256[2], uint256[2]));\n\n\t// Call target = token to give\n\trequire(addresses[2] == tokenGiveGet[0], \"ERC3525: call target must equal address of token to give\");\n\t// Assert more than zero\n\trequire(transferValues[0] > 0,\"ERC3525: give transfer value must be larger than zero\");\n\t// Call type = call\n\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC3525: call must be a direct call\");\n\t// Assert calldata\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], voucherGiveGet[0], transferValues[0], \"\")));\n\n\t// Countercall target = token to get\n\trequire(addresses[5] == tokenGiveGet[1], \"ERC3525: countercall target must equal address of token to get\");\n\t// Assert more than zero\n\trequire(transferValues[1] > 0,\"ERC3525: take amount must be larger than zero\");\n\t// Countercall type = call\n\trequire(howToCalls[1] == AuthenticatedProxy.HowToCall.Call, \"ERC3525: countercall must be a direct call\");\n\t// Assert countercalldata\n\trequire(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[4], addresses[1], voucherGiveGet[1], transferValues[1], \"\")));\n\n\t// Mark filled\n\treturn 1;\n}\n\nfunction swapOneForOneERC3525Decoding(bytes memory extra,\n\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n\tbytes memory data, bytes memory counterdata)\n\tpublic\n\tpure\n\treturns (uint)\n{\n\t// Calculate function signature\n\tbytes memory sig = ArrayUtils.arrayTake(abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\"), 4);\n\n\t// Zero-value\n\trequire(uints[0] == 0);\n\n\t// Decode extradata\n\t(address[2] memory tokenGiveGet, uint256[2] memory voucherGiveGet, uint256[2] memory transferValues) = abi.decode(extra, (address[2],uint256[2],uint256[2]));\n\n\t// Call target = token to give\n\trequire(addresses[2] == tokenGiveGet[0], \"ERC3525: call target must equal address of token to give\");\n\t// Call type = call\n\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC3525: call must be a direct call\");\n\t// Assert signature\n\trequire(ArrayUtils.arrayEq(sig, ArrayUtils.arrayTake(data, 4)));\n\t// Decode and assert calldata\t\n\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[1], addresses[4], voucherGiveGet[0], transferValues[0], \"\")));\n\t// Decode and assert countercalldata\n\trequire(ArrayUtils.arrayEq(counterdata, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", addresses[4], addresses[1], voucherGiveGet[1], transferValues[1], \"\")));\n\n\t// Mark filled\n\treturn 1;\n}\n\n}\n"
    },
    "contracts/static/StaticUtil.sol": {
      "content": "/*\n\n    StaticUtil - static call utility contract\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"../lib/StaticCaller.sol\";\nimport \"../lib/ArrayUtils.sol\";\nimport \"../registry/AuthenticatedProxy.sol\";\n\ncontract StaticUtil is StaticCaller {\n\n    address public atomicizer;\n\n    function any(bytes memory, address[7] memory, AuthenticatedProxy.HowToCall[2] memory, uint[6] memory, bytes memory, bytes memory)\n        public\n        pure\n        returns (uint)\n    {\n        /*\n           Accept any call.\n           Useful e.g. for matching-by-transaction, where you authorize the counter-call by sending the transaction and don't need to re-check it.\n           Return fill \"1\".\n        */\n\n        return 1;\n    }\n\n    function anySingle(bytes memory,  address[7] memory, AuthenticatedProxy.HowToCall, uint[6] memory, bytes memory)\n        public\n        pure\n    {\n        /* No checks. */\n    }\n\n    function anyNoFill(bytes memory, address[7] memory, AuthenticatedProxy.HowToCall[2] memory, uint[6] memory, bytes memory, bytes memory)\n        public\n        pure\n        returns (uint)\n    {\n        /*\n           Accept any call.\n           Useful e.g. for matching-by-transaction, where you authorize the counter-call by sending the transaction and don't need to re-check it.\n           Return fill \"0\".\n        */\n\n        return 0;\n    }\n\n    function anyAddOne(bytes memory, address[7] memory, AuthenticatedProxy.HowToCall[2] memory, uint[6] memory uints, bytes memory, bytes memory)\n        public\n        pure\n        returns (uint)\n    {\n        /*\n           Accept any call.\n           Useful e.g. for matching-by-transaction, where you authorize the counter-call by sending the transaction and don't need to re-check it.\n           Return the current fill plus 1.\n        */\n\n        return uints[5] + 1;\n    }\n\n    function split(bytes memory extra,\n                   address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n                   bytes memory data, bytes memory counterdata)\n        public\n        view\n        returns (uint)\n    {\n        (address[2] memory targets, bytes4[2] memory selectors, bytes memory firstExtradata, bytes memory secondExtradata) = abi.decode(extra, (address[2], bytes4[2], bytes, bytes));\n\n        /* Split into two static calls: one for the call, one for the counter-call, both with metadata. */\n\n        /* Static call to check the call. */\n        require(staticCall(targets[0], abi.encodeWithSelector(selectors[0], firstExtradata, addresses, howToCalls[0], uints, data)));\n\n        /* Static call to check the counter-call. */\n        require(staticCall(targets[1], abi.encodeWithSelector(selectors[1], secondExtradata, [addresses[3], addresses[4], addresses[5], addresses[0], addresses[1], addresses[2], addresses[6]], howToCalls[1], uints, counterdata)));\n\n        return 1;\n    }\n\n    function splitAddOne(bytes memory extra,\n                   address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n                   bytes memory data, bytes memory counterdata)\n        public\n        view\n        returns (uint)\n    {\n        split(extra,addresses,howToCalls,uints,data,counterdata);\n        return uints[5] + 1;\n    }\n\n    function and(bytes memory extra,\n                 address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n                 bytes memory data, bytes memory counterdata)\n        public\n        view\n    {\n        (address[] memory addrs, bytes4[] memory selectors, uint[] memory extradataLengths, bytes memory extradatas) = abi.decode(extra, (address[], bytes4[], uint[], bytes));\n\n        require(addrs.length == extradataLengths.length);\n        \n        uint j = 0;\n        for (uint i = 0; i < addrs.length; i++) {\n            bytes memory extradata = new bytes(extradataLengths[i]);\n            for (uint k = 0; k < extradataLengths[i]; k++) {\n                extradata[k] = extradatas[j];\n                j++;\n            }\n            require(staticCall(addrs[i], abi.encodeWithSelector(selectors[i], extradata, addresses, howToCalls, uints, data, counterdata)));\n        }\n    }\n\n    function or(bytes memory extra,\n                address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n                bytes memory data, bytes memory counterdata)\n        public\n        view\n    {\n        (address[] memory addrs, bytes4[] memory selectors, uint[] memory extradataLengths, bytes memory extradatas) = abi.decode(extra, (address[], bytes4[], uint[], bytes));\n\n        require(addrs.length == extradataLengths.length, \"Different number of static call addresses and extradatas\");\n        \n        uint j = 0;\n        for (uint i = 0; i < addrs.length; i++) {\n            bytes memory extradata = new bytes(extradataLengths[i]);\n            for (uint k = 0; k < extradataLengths[i]; k++) {\n                extradata[k] = extradatas[j];\n                j++;\n            }\n            if (staticCall(addrs[i], abi.encodeWithSelector(selectors[i], extradata, addresses, howToCalls, uints, data, counterdata))) {\n                return;\n            }\n        }\n\n        revert(\"No static calls succeeded\");\n    }\n\n    function sequenceExact(bytes memory extra,\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory uints,\n        bytes memory cdata)\n        public\n        view\n    {\n        (address[] memory addrs, uint[] memory extradataLengths, bytes4[] memory selectors, bytes memory extradatas) = abi.decode(extra, (address[], uint[], bytes4[], bytes));\n\n        /* Assert DELEGATECALL to atomicizer library with given call sequence, split up predicates accordingly.\n           e.g. transferring two CryptoKitties in sequence. */\n\n        require(addrs.length == extradataLengths.length);\n\n        (address[] memory caddrs, uint[] memory cvals, uint[] memory clengths, bytes memory calldatas) = abi.decode(ArrayUtils.arrayDrop(cdata, 4), (address[], uint[], uint[], bytes));\n\n        require(addresses[2] == atomicizer);\n        require(howToCall == AuthenticatedProxy.HowToCall.DelegateCall);\n        require(addrs.length == caddrs.length); // Exact calls only\n\n        for (uint i = 0; i < addrs.length; i++) {\n            require(cvals[i] == 0);\n        }\n\n        sequence(caddrs, clengths, calldatas, addresses, uints, addrs, extradataLengths, selectors, extradatas);\n    }\n\n    function dumbSequenceExact(bytes memory extra,\n        address[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n        bytes memory cdata, bytes memory)\n        public\n        view\n        returns (uint)\n    {\n        sequenceExact(extra, addresses, howToCalls[0], uints, cdata);\n\n        return 1;\n    }\n\n    function sequenceAnyAfter(bytes memory extra,\n        address[7] memory addresses, AuthenticatedProxy.HowToCall howToCall, uint[6] memory uints,\n        bytes memory cdata)\n        public\n        view\n    {\n        (address[] memory addrs, uint[] memory extradataLengths, bytes4[] memory selectors, bytes memory extradatas) = abi.decode(extra, (address[], uint[], bytes4[], bytes));\n\n        /* Assert DELEGATECALL to atomicizer library with given call sequence, split up predicates accordingly.\n           e.g. transferring two CryptoKitties in sequence. */\n\n        require(addrs.length == extradataLengths.length);\n\n        (address[] memory caddrs, uint[] memory cvals, uint[] memory clengths, bytes memory calldatas) = abi.decode(ArrayUtils.arrayDrop(cdata, 4), (address[], uint[], uint[], bytes));\n\n        require(addresses[2] == atomicizer);\n        require(howToCall == AuthenticatedProxy.HowToCall.DelegateCall);\n        require(addrs.length <= caddrs.length); // Extra calls OK\n\n        for (uint i = 0; i < addrs.length; i++) {\n            require(cvals[i] == 0);\n        }\n\n        sequence(caddrs, clengths, calldatas, addresses, uints, addrs, extradataLengths, selectors, extradatas);\n    }\n\n    function sequence(\n        address[] memory caddrs, uint[] memory clengths, bytes memory calldatas,\n        address[7] memory addresses, uint[6] memory uints,\n        address[] memory addrs, uint[] memory extradataLengths, bytes4[] memory selectors, bytes memory extradatas)\n        internal\n        view\n    {\n        uint j = 0;\n        uint l = 0;\n        for (uint i = 0; i < addrs.length; i++) {\n            bytes memory extradata = new bytes(extradataLengths[i]);\n            for (uint k = 0; k < extradataLengths[i]; k++) {\n                extradata[k] = extradatas[j];\n                j++;\n            }\n            bytes memory data = new bytes(clengths[i]);\n            for (uint m = 0; m < clengths[i]; m++) {\n                data[m] = calldatas[l];\n                l++;\n            }\n            addresses[2] = caddrs[i];\n            require(staticCall(addrs[i], abi.encodeWithSelector(selectors[i], extradata, addresses, AuthenticatedProxy.HowToCall.Call, uints, data)));\n        }\n        require(j == extradatas.length);\n    }\n\n}\n"
    },
    "contracts/StaticMarket.sol": {
      "content": "/*\n\n  << Static Market contract >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"./lib/ArrayUtils.sol\";\nimport \"./registry/AuthenticatedProxy.sol\";\n\n/**\n * @title StaticMarket\n * @author Wyvern Protocol Developers\n */\ncontract StaticMarket {\n\n\tstring public constant name = \"Static Market\";\n\n\tconstructor ()\n\t\tpublic\n\t{}\n\n\tfunction anyERC1155ForERC20(bytes memory extra,\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n\t\tbytes memory data, bytes memory counterdata)\n\t\tpublic\n\t\tpure\n\t\treturns (uint)\n\t{\n\t\trequire(uints[0] == 0,\"anyERC1155ForERC20: Zero value required\");\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"anyERC1155ForERC20: call must be a direct call\");\n\n\t\t(address[2] memory tokenGiveGet, uint256[3] memory tokenIdAndNumeratorDenominator) = abi.decode(extra, (address[2], uint256[3]));\n\n\t\trequire(tokenIdAndNumeratorDenominator[1] > 0,\"anyERC20ForERC1155: numerator must be larger than zero\");\n\t\trequire(tokenIdAndNumeratorDenominator[2] > 0,\"anyERC20ForERC1155: denominator must be larger than zero\");\n\t\trequire(addresses[2] == tokenGiveGet[0], \"anyERC1155ForERC20: call target must equal address of token to give\");\n\t\trequire(addresses[5] == tokenGiveGet[1], \"anyERC1155ForERC20: countercall target must equal address of token to get\");\n\n\t\tuint256[2] memory call_amounts = [\n\t\t\tgetERC1155AmountFromCalldata(data),\n\t\t\tgetERC20AmountFromCalldata(counterdata)\n\t\t];\n\t\tuint256 new_fill = SafeMath.add(uints[5],call_amounts[0]);\n\t\trequire(new_fill <= uints[1],\"anyERC1155ForERC20: new fill exceeds maximum fill\");\n\t\trequire(SafeMath.mul(tokenIdAndNumeratorDenominator[1], call_amounts[1]) == SafeMath.mul(tokenIdAndNumeratorDenominator[2], call_amounts[0]),\"anyERC1155ForERC20: wrong ratio\");\n\t\tcheckERC1155Side(data,addresses[1],addresses[4],tokenIdAndNumeratorDenominator[0],call_amounts[0]);\n\t\tcheckERC20Side(counterdata,addresses[4],addresses[1],call_amounts[1]);\n\t\t\n\t\treturn new_fill;\n\t}\n\n\tfunction anyERC20ForERC1155(bytes memory extra,\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n\t\tbytes memory data, bytes memory counterdata)\n\t\tpublic\n\t\tpure\n\t\treturns (uint)\n\t{\n\t\trequire(uints[0] == 0,\"anyERC20ForERC1155: Zero value required\");\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"anyERC20ForERC1155: call must be a direct call\");\n\n\t\t(address[2] memory tokenGiveGet, uint256[3] memory tokenIdAndNumeratorDenominator) = abi.decode(extra, (address[2], uint256[3]));\n\n\t\trequire(tokenIdAndNumeratorDenominator[1] > 0,\"anyERC20ForERC1155: numerator must be larger than zero\");\n\t\trequire(tokenIdAndNumeratorDenominator[2] > 0,\"anyERC20ForERC1155: denominator must be larger than zero\");\n\t\trequire(addresses[2] == tokenGiveGet[0], \"anyERC20ForERC1155: call target must equal address of token to get\");\n\t\trequire(addresses[5] == tokenGiveGet[1], \"anyERC20ForERC1155: countercall target must equal address of token to give\");\n\n\t\tuint256[2] memory call_amounts = [\n\t\t\tgetERC1155AmountFromCalldata(counterdata),\n\t\t\tgetERC20AmountFromCalldata(data)\n\t\t];\n\t\tuint256 new_fill = SafeMath.add(uints[5],call_amounts[1]);\n\t\trequire(new_fill <= uints[1],\"anyERC20ForERC1155: new fill exceeds maximum fill\");\n\t\trequire(SafeMath.mul(tokenIdAndNumeratorDenominator[1], call_amounts[0]) == SafeMath.mul(tokenIdAndNumeratorDenominator[2], call_amounts[1]),\"anyERC20ForERC1155: wrong ratio\");\n\t\tcheckERC1155Side(counterdata,addresses[4],addresses[1],tokenIdAndNumeratorDenominator[0],call_amounts[0]);\n\t\tcheckERC20Side(data,addresses[1],addresses[4],call_amounts[1]);\n\t\t\n\t\treturn new_fill;\n\t}\n\n\tfunction anyERC20ForERC20(bytes memory extra,\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n\t\tbytes memory data, bytes memory counterdata)\n\t\tpublic\n\t\tpure\n\t\treturns (uint)\n\t{\n\t\trequire(uints[0] == 0,\"anyERC20ForERC20: Zero value required\");\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"anyERC20ForERC20: call must be a direct call\");\n\n\t\t(address[2] memory tokenGiveGet, uint256[2] memory numeratorDenominator) = abi.decode(extra, (address[2], uint256[2]));\n\n\t\trequire(numeratorDenominator[0] > 0,\"anyERC20ForERC20: numerator must be larger than zero\");\n\t\trequire(numeratorDenominator[1] > 0,\"anyERC20ForERC20: denominator must be larger than zero\");\n\t\trequire(addresses[2] == tokenGiveGet[0], \"anyERC20ForERC20: call target must equal address of token to give\");\n\t\trequire(addresses[5] == tokenGiveGet[1], \"anyERC20ForERC20: countercall target must equal address of token to get\");\n\t\t\n\t\tuint256[2] memory call_amounts = [\n\t\t\tgetERC20AmountFromCalldata(data),\n\t\t\tgetERC20AmountFromCalldata(counterdata)\n\t\t];\n\t\tuint256 new_fill = SafeMath.add(uints[5],call_amounts[0]);\n\t\trequire(new_fill <= uints[1],\"anyERC20ForERC20: new fill exceeds maximum fill\");\n\t\trequire(SafeMath.mul(numeratorDenominator[0],call_amounts[0]) == SafeMath.mul(numeratorDenominator[1],call_amounts[1]),\"anyERC20ForERC20: wrong ratio\");\n\t\tcheckERC20Side(data,addresses[1],addresses[4],call_amounts[0]);\n\t\tcheckERC20Side(counterdata,addresses[4],addresses[1],call_amounts[1]);\n\t\t\n\t\treturn new_fill;\n\t}\n\n\tfunction ERC721ForERC20(bytes memory extra,\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n\t\tbytes memory data, bytes memory counterdata)\n\t\tpublic\n\t\tpure\n\t\treturns (uint)\n\t{\n\t\trequire(uints[0] == 0,\"ERC721ForERC20: Zero value required\");\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC721ForERC20: call must be a direct call\");\n\n\t\t(address[2] memory tokenGiveGet, uint256[2] memory tokenIdAndPrice) = abi.decode(extra, (address[2], uint256[2]));\n\n\t\trequire(tokenIdAndPrice[1] > 0,\"ERC721ForERC20: ERC721 price must be larger than zero\");\n\t\trequire(addresses[2] == tokenGiveGet[0], \"ERC721ForERC20: call target must equal address of token to give\");\n\t\trequire(addresses[5] == tokenGiveGet[1], \"ERC721ForERC20: countercall target must equal address of token to get\");\n\n\t\tcheckERC721Side(data,addresses[1],addresses[4],tokenIdAndPrice[0]);\n\t\tcheckERC20Side(counterdata,addresses[4],addresses[1],tokenIdAndPrice[1]);\n\t\t\n\t\treturn 1;\n\t}\n\n\tfunction ERC20ForERC721(bytes memory extra,\n\t\taddress[7] memory addresses, AuthenticatedProxy.HowToCall[2] memory howToCalls, uint[6] memory uints,\n\t\tbytes memory data, bytes memory counterdata)\n\t\tpublic\n\t\tpure\n\t\treturns (uint)\n\t{\n\t\trequire(uints[0] == 0,\"ERC20ForERC721: Zero value required\");\n\t\trequire(howToCalls[0] == AuthenticatedProxy.HowToCall.Call, \"ERC20ForERC721: call must be a direct call\");\n\n\t\t(address[2] memory tokenGiveGet, uint256[2] memory tokenIdAndPrice) = abi.decode(extra, (address[2], uint256[2]));\n\n\t\trequire(tokenIdAndPrice[1] > 0,\"ERC20ForERC721: ERC721 price must be larger than zero\");\n\t\trequire(addresses[2] == tokenGiveGet[0], \"ERC20ForERC721: call target must equal address of token to give\");\n\t\trequire(addresses[5] == tokenGiveGet[1], \"ERC20ForERC721: countercall target must equal address of token to get\");\n\n\t\tcheckERC721Side(counterdata,addresses[4],addresses[1],tokenIdAndPrice[0]);\n\t\tcheckERC20Side(data,addresses[1],addresses[4],tokenIdAndPrice[1]);\n\t\t\n\t\treturn 1;\n\t}\n\n\tfunction getERC1155AmountFromCalldata(bytes memory data)\n\t\tinternal\n\t\tpure\n\t\treturns (uint256)\n\t{\n\t\t(uint256 amount) = abi.decode(ArrayUtils.arraySlice(data,100,32),(uint256));\n\t\treturn amount;\n\t}\n\n\tfunction getERC20AmountFromCalldata(bytes memory data)\n\t\tinternal\n\t\tpure\n\t\treturns (uint256)\n\t{\n\t\t(uint256 amount) = abi.decode(ArrayUtils.arraySlice(data,68,32),(uint256));\n\t\treturn amount;\n\t}\n\n\tfunction checkERC1155Side(bytes memory data, address from, address to, uint256 tokenId, uint256 amount)\n\t\tinternal\n\t\tpure\n\t{\n\t\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"safeTransferFrom(address,address,uint256,uint256,bytes)\", from, to, tokenId, amount, \"\")));\n\t}\n\n\tfunction checkERC721Side(bytes memory data, address from, address to, uint256 tokenId)\n\t\tinternal\n\t\tpure\n\t{\n\t\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, tokenId)));\n\t}\n\n\tfunction checkERC20Side(bytes memory data, address from, address to, uint256 amount)\n\t\tinternal\n\t\tpure\n\t{\n\t\trequire(ArrayUtils.arrayEq(data, abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", from, to, amount)));\n\t}\n}\n"
    },
    "contracts/TestERC20.sol": {
      "content": "/*\n\n  << TestERC20 >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestERC20 is ERC20(\"test\", \"TST\") {\n\n    /**\n     */\n    constructor () public {\n    }\n\n    /**\n     */\n    function mint(address to, uint256 value) public returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n\n}\n"
    },
    "contracts/TestERC3525/TestERC3525.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.5;\n\nimport \"./VNFTCore.sol\";\n\ncontract TestERC3525 is VNFTCore {\n    using SafeMath for uint256;\n    using SafeMath for uint64;\n\n    address public admin;\n    address public pendingAdmin;\n\n    bool internal _notEntered;\n    uint8 public unitDecimals;\n    uint32 public nextTokenId;\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(_notEntered, \"re-entered\");\n        _notEntered = false;\n        _;\n        _notEntered = true;\n        // get a gas-refund post-Istanbul\n    }\n\n    constructor() VNFTCore(\"TestERC3525\", \"3525\", \"\", \"\")  {\n        admin = msg.sender;\n\n        nextTokenId = 100000000;\n        _notEntered = true;\n    }\n\n     function mint(uint256 slot_, uint256 tokenId_, uint256 units_) external {\n\n        VNFTCore._mintUnits(msg.sender, tokenId_, slot_, units_);\n    }\n\n    function owner() external view virtual returns (address) {\n        return admin;\n    }\n\n    function setContractURI(string memory uri_) external virtual onlyAdmin {\n        VNFTCore._setContractURI(uri_);\n    }\n\n    function setTokenURI(uint256 tokenId_, string memory uri_)\n        external\n        virtual\n        onlyAdmin\n    {\n        ERC721._setTokenURI(tokenId_, uri_);\n    }\n\n    function setBaseURI(string memory uri_) external virtual onlyAdmin {\n        ERC721._setBaseURI(uri_);\n    }\n\n    function split(uint256 tokenId_, uint256[] calldata splitUnits_)\n        external\n        virtual\n        override\n        returns (uint256[] memory newTokenIds)\n    {\n        require(splitUnits_.length > 0, \"empty splitUnits\");\n        newTokenIds = new uint256[](splitUnits_.length);\n        for (uint256 i = 0; i < splitUnits_.length; i++) {\n            newTokenIds[i] = _splitUnits(tokenId_, splitUnits_[i]);\n        }\n\n        return newTokenIds;\n    }\n\n    function _splitUnits(uint256 tokenId_, uint256 splitUnits_)\n        internal\n        virtual\n        returns (uint256 newTokenId)\n    {\n        newTokenId = nextTokenId + tokenId_;\n\n        VNFTCore._splitUnits(tokenId_, newTokenId, splitUnits_);\n\n        return newTokenId;\n    }\n\n    function merge(uint256[] calldata tokenIds_, uint256 targetTokenId_)\n        external\n        virtual\n        override\n    {\n        require(tokenIds_.length > 0, \"empty tokenIds\");\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            _merge(tokenIds_[i], targetTokenId_);\n        }\n    }\n\n    function _merge(uint256 tokenId_, uint256 targetTokenId_)\n        internal\n        virtual\n        override\n    {\n        VNFTCore._merge(tokenId_, targetTokenId_);\n    }\n\n    /**\n     * @notice Transfer part of units of a Voucher to target address.\n     * @param from_ Address of the Voucher sender\n     * @param to_ Address of the Voucher recipient\n     * @param tokenId_ Id of the Voucher to transfer\n     * @param transferUnits_ Amount of units to transfer\n     */\n    function transferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 transferUnits_\n    ) public virtual override returns (uint256 newTokenId) {\n        newTokenId = nextTokenId + tokenId_;\n        _transferUnitsFrom(from_, to_, tokenId_, newTokenId, transferUnits_);\n    }\n\n    /**\n     * @notice Transfer part of units of a Voucher to another Voucher.\n     * @param from_ Address of the Voucher sender\n     * @param to_ Address of the Voucher recipient\n     * @param tokenId_ Id of the Voucher to transfer\n     * @param targetTokenId_ Id of the Voucher to receive\n     * @param transferUnits_ Amount of units to transfer\n     */\n    function transferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_\n    ) public virtual override {\n        require(_exists(targetTokenId_), \"target token not exists\");\n        _transferUnitsFrom(\n            from_,\n            to_,\n            tokenId_,\n            targetTokenId_,\n            transferUnits_\n        );\n    }\n\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_,\n        bytes memory data_\n    ) external virtual override {\n        transferFrom(from_, to_, tokenId_, targetTokenId_, transferUnits_);\n        require(\n            _checkOnVNFTReceived(\n                from_,\n                to_,\n                targetTokenId_,\n                transferUnits_,\n                data_\n            ),\n            \"to non VNFTReceiver\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 transferUnits_,\n        bytes memory data_\n    ) external virtual override returns (uint256 newTokenId) {\n        newTokenId = transferFrom(from_, to_, tokenId_, transferUnits_);\n        require(\n            _checkOnVNFTReceived(from_, to_, newTokenId, transferUnits_, data_),\n            \"to non VNFTReceiver\"\n        );\n        return newTokenId;\n    }\n\n    function _transferUnitsFrom(\n        address from_,\n        address to_,\n        uint256 tokenId_,\n        uint256 targetTokenId_,\n        uint256 transferUnits_\n    ) internal virtual override {\n        VNFTCore._transferUnitsFrom(\n            from_,\n            to_,\n            tokenId_,\n            targetTokenId_,\n            transferUnits_\n        );\n    }\n\n    function _sub(uint64 a, uint64 b) internal pure returns (uint64) {\n        require(b <= a, \"sub-overflow\");\n        return a - b;\n    }\n}\n"
    },
    "contracts/TestAuthenticatedProxy.sol": {
      "content": "/**\n\n  << TestAuthenticatedProxy >>\n\n  Just for DelegateCall testing.\n\n**/\n\npragma solidity 0.7.5;\n\nimport \"./registry/AuthenticatedProxy.sol\";\n\ncontract TestAuthenticatedProxy is AuthenticatedProxy {\n\n    function setUser(address newUser)\n        public\n    {\n        registry.transferAccessTo(user, newUser);\n        user = newUser;\n    }\n\n}\n"
    },
    "contracts/TestERC1271.sol": {
      "content": "/*\n\n  << TestERC1271 >>\n\n*/\n\npragma solidity 0.7.5;\n\nimport \"./lib/EIP1271.sol\";\n\ncontract TestERC1271 is ERC1271 {\n\n    bytes4 constant internal SIGINVALID = 0x00000000;\n\n    address internal owner;\n\n    /**\n     * Set a new owner (for testing)\n     *\n     * @param ownerAddr Address of owner\n     */\n    function setOwner (address ownerAddr)\n        public\n    {\n        owner = ownerAddr;\n    }\n\n    /**\n     * Check if a signature is valid\n     *\n     * @param _hash Hash of the data to be signed\n     * @param _signature Signature encoded as (bytes32 r, bytes32 s, uint8 v)\n     * @return magicValue Magic value if valid, zero-value otherwise\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature)\n        override\n        public\n        view\n        returns (bytes4 magicValue)\n    {\n        (uint8 v, bytes32 r, bytes32 s) = abi.decode(_signature, (uint8, bytes32, bytes32));\n        if (owner == ecrecover(_hash, v, r, s)) {\n            return MAGICVALUE;\n        } else {\n            return SIGINVALID;\n        }\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}